"""
Adapted from the sentinel 2 reader:

This code is generated by Ridvan Salih KUZU @DLR
LAST EDITED:  14.09.2021
ABOUT SCRIPT:
It defines a data reader for Sentinel-2 eath observation data
"""

import os
import torch
from torch.utils.data import Dataset
import zipfile
import tarfile
from sh import gunzip
from glob import glob
import pickle
import geopandas as gpd
import numpy as np
import rasterio as rio
from rasterio import features
from tqdm import tqdm

from itertools import repeat
from multiprocessing import Pool, RawArray
import time

var_dict= {} # global variable for the multiprocessing

class S2Reader(Dataset):
    """
    THIS CLASS INITIALIZES THE DATA READER FOR SENTINEL-2 DATA
    """
    def __init__(self, input_dir, label_dir, output_dir=None, label_ids=None, transform=None, min_area_to_ignore = 1000, selected_time_points=None, include_cloud=False, overwrite=True, n_processes=1):
        '''
        THIS FUNCTION INITIALIZES DATA READER.
        :param input_dir: directory of input images in zip format
        :param label_dir: directory of ground-truth polygons in GeoJSON format
        :param output_dir: directory where to store the zipped processes patches
        :param label_ids: an array of crop IDs in order. if the crop labels in GeoJSON data is not started from index 0 it can be used. Otherwise it is not required.
        :param transform: data transformer function for the augmentation or data processing
        :param min_area_to_ignore: threshold m2 to eliminate small agricultural fields less than a certain threshold. By default, threshold is 1000 m2
        :param selected_time_points: If a sub set of the time series will be exploited, it can determine the index of those times in a given time series dataset
        :param overwrite: Overwrite the preprocessed data
        :param n_processes: Parallel processing during setup (default: single core)

        :return: None
        '''

        if include_cloud:
            raise ValueError("Not implemented with transform: include_cloud = True")

        self.data_transform = transform
        self.selected_time_points=selected_time_points
        self.crop_ids = label_ids
        if label_ids is not None and not isinstance(label_ids, list):
            self.crop_ids = label_ids.tolist()

        if output_dir is None:
            self.npyfolder = input_dir.replace(".zip", "/time_series")
        else:
            self.npyfolder = output_dir
        self.labels = S2Reader._setup(input_dir, label_dir,self.npyfolder,min_area_to_ignore, include_cloud, overwrite, n_processes)

    def __len__(self):
        """
        THIS FUNCTION RETURNS THE LENGTH OF DATASET
        """
        return len(self.labels)

    def __getitem__(self, item):
        """
        THIS FUNCTION ITERATE OVER THE DATASET BY GIVEN ITEM NO AND RETURNS FOLLOWINGS:
        :return: image_stack in size of [Time Stamp, Image Dimension (Channel), Height, Width] , crop_label, field_mask in size of [Height, Width], field_id
        """

        feature = self.labels.iloc[item]

        npyfile = os.path.join(self.npyfolder, "fid_{}.npz".format(feature.fid))
        if os.path.exists(npyfile): # use saved numpy array if already created
            try:
                object = np.load(npyfile)
                image_stack = object["image_stack"]
                cloud_stack = object["cloud_stack"]
                mask = object["mask"]
            except zipfile.BadZipFile:
                print("ERROR: {} is a bad zipfile...".format(npyfile))
                return None
        else:
            print("ERROR: {} is a missing...".format(npyfile))
            return None

        if self.data_transform is not None: # TODO add cloud_stack option here (filter, interpolate, ...)
            image_stack, mask = self.data_transform(image_stack, mask)

        if self.selected_time_points is not None:
            image_stack = image_stack[self.selected_time_points]

        label = feature.crop_id

        return image_stack, label, mask, feature.fid, feature.crop_name

    @staticmethod
    def _setup(rootpath, labelgeojson, npyfolder, min_area_to_ignore=1000,include_cloud=False, overwrite=False, n_processes=1):
        """
         THIS FUNCTION PREPARES THE PLANET READER BY SPLITTING AND RASTERIZING EACH CROP FIELD AND SAVING INTO SEPERATE FILES FOR SPEED UP THE FURTHER USE OF DATA.

         This utility function unzipps a dataset and performs a field-wise aggregation.
         results are written to a .npz cache with same name as zippath

         :param rootpath: directory of input images in ZIP format
         :param labelgeojson: directory of ground-truth polygons in GeoJSON format
         :param npyfolder: folder to save the field data for each field polygon
         :param min_area_to_ignore: threshold m2 to eliminate small agricultural fields less than a certain threshold. By default, threshold is 1000 m2
         :param include_cloud: It includes cloud probabilities inti image_stack if TRUE, othervise it saves the cloud info as sepeate array
         :param overwrite: If TRUE, overwrite the previously setup data
         :param n_processes: Parallel processes for polygon extraction, default: 1

         :return: labels of the saved fields
         """


        with open(os.path.join(rootpath, "bbox.pkl"), 'rb') as f:
            bbox = pickle.load(f)
            crs = str(bbox.crs)
            minx, miny, maxx, maxy = bbox.min_x, bbox.min_y, bbox.max_x, bbox.max_y

        labels = gpd.read_file(labelgeojson)
        # project to same coordinate reference system (crs) as the imagery
        ignore = labels.geometry.area > min_area_to_ignore
        print(f"INFO: Ignoring {(~ignore).sum()}/{len(ignore)} fields with area < {min_area_to_ignore}m2")
        labels = labels.loc[ignore]
        labels = labels.to_crs(crs) #TODO: CHECK IF NECESSARY

        bands = np.load(os.path.join(rootpath, "bands.npy"))
        clp = np.load(os.path.join(rootpath, "clp.npy")) #CLOUD PROBABILITY
        if include_cloud:
            bands = np.concatenate([bands, clp], axis=-1) # concat cloud probability
        _, width, height, _ = bands.shape

        bands = bands.transpose(0, 3, 1, 2).astype(np.float32)
        clp = clp.transpose(0, 3, 1, 2).astype(np.float32)

        transform = rio.transform.from_bounds(minx, miny, maxx, maxy, width, height)

        fid_mask = features.rasterize(zip(labels.geometry, labels.fid), all_touched=True,
                                      transform=transform, out_shape=(width, height))
        assert len(np.unique(fid_mask)) > 0, f"WARNING: Vectorized fid mask contains no fields. " \
                                             f"Does the label geojson {labelgeojson} cover the region defined by {rootpath}?"

        crop_mask = features.rasterize(zip(labels.geometry, labels.crop_id), all_touched=True,
                                       transform=transform, out_shape=(width, height))
        assert len(np.unique(crop_mask)) > 0, f"WARNING: Vectorized fid mask contains no fields. " \
                                              f"Does the label geojson {labelgeojson} cover the region defined by {rootpath}?"

        # prepare for multiprocessing
        print('starting the multiprocessing preparation')
        # https://research.wmz.ninja/articles/2018/03/on-sharing-large-arrays-when-using-pythons-html
        p_bands = RawArray('f', bands.flatten().shape[0])
        p_clp = RawArray('f', clp.flatten().shape[0])
        p_fid_mask = RawArray('f', fid_mask.flatten().shape[0])
        # wrap buffers as np arrays for easier manipulation
        p_bands_np = np.frombuffer(p_bands, dtype=np.float32).reshape(bands.shape)
        p_clp_np = np.frombuffer(p_clp, dtype=np.float32).reshape(clp.shape)
        p_fid_mask_np = np.frombuffer(p_fid_mask, dtype=np.float32).reshape(fid_mask.shape)
        # copy data to shared arrays
        start_time = time.time()
        np.copyto(p_bands_np, bands.astype(np.float32))
        np.copyto(p_clp_np, clp.astype(np.float32))
        np.copyto(p_fid_mask_np, fid_mask.astype(np.float32))

        print(f'Copied data to shared arrays in {time.time() - start_time:.0f} seconds')

        def init_worker(bands, bands_shape, clp, clp_shape, fid_mask, fid_mask_shape, npyfolder, transform, overwrite):
            var_dict['bands'] = p_bands # raw array
            var_dict['bands_shape'] = bands.shape # shape
            var_dict['clp'] = p_clp # raw array
            var_dict['clp_shape'] = clp.shape # shape
            var_dict['fid_mask'] = p_fid_mask # raw array
            var_dict['fid_mask_shape'] = fid_mask.shape # shape
            var_dict['npyfolder'] = npyfolder
            var_dict['transform'] = transform
            var_dict['overwrite'] = overwrite

        initargs = (bands, bands.shape, clp, clp.shape, fid_mask, fid_mask.shape, npyfolder, transform, overwrite)

        with Pool(n_processes, initializer=init_worker, initargs=initargs) as p:
            print(f'Starting {n_processes} parallel processes')
            start_time = time.time()
            p.starmap(S2Reader._extract_field, labels.iterrows())
            print(f'Finished setup in {(time.time() - start_time) / 60:.2f} minutes')

        return labels

    @staticmethod
    def _extract_field(index, feature):
        '''
        Separate function for extracting the individual polygons
        For use with Pool
        '''

        # from buffer
        bands = np.frombuffer(var_dict['bands'], dtype=np.float32).reshape(var_dict['bands_shape'])
        clp = np.frombuffer(var_dict['clp'], dtype=np.float32).reshape(var_dict['clp_shape'])
        fid_mask = np.frombuffer(var_dict['fid_mask'], dtype=np.float32).reshape(var_dict['fid_mask_shape'])
        npyfolder = var_dict['npyfolder']
        transform = var_dict['transform']
        overwrite = var_dict['overwrite']

        npyfile = os.path.join(npyfolder, "fid_{}.npz".format(feature.fid))
        if overwrite or not os.path.exists(npyfile): 
            left, bottom, right, top = feature.geometry.bounds
            window = rio.windows.from_bounds(left, bottom, right, top, transform)

            row_start = max(0, round(window.row_off)) # if field extends beyond area
            row_end = round(window.row_off) + round(window.height)
            col_start = max(0, round(window.col_off))
            col_end = round(window.col_off) + round(window.width)

            image_stack = bands[:, :,row_start:row_end, col_start:col_end]
            cloud_stack = clp[:, :,row_start:row_end, col_start:col_end]
            mask = fid_mask[row_start:row_end, col_start:col_end] == feature.fid

            os.makedirs(npyfolder, exist_ok=True)
            np.savez(npyfile, image_stack=image_stack.astype(np.float32), cloud_stack=cloud_stack.astype(np.float32), 
                              mask=mask.astype(np.float32), feature=feature.drop("geometry").to_dict())

if __name__ == '__main__':
    """
    EXAMPLE USAGE OF DATA READER
    """

    zippath = "../data/dlr_fusion_competition_germany_train_source_sentinel_2.tar.gz"

    labelgeojson = "../data/dlr_fusion_competition_germany_train_labels/dlr_fusion_competition_germany_train_labels_33N_18E_242N/labels.geojson"
    ds = S2Reader(zippath, labelgeojson)
    X,y,m,fid = ds[0]
